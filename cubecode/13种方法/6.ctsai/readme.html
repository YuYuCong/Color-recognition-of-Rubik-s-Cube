<html>
<head>
<title>readme</title>
<style>
h1 {font: normal 24pt "Arial"}
h2 {font: bold 12pt "Arial"}
h3 {font: normal 10pt "Arial"}
</style>
</head>
<body>
<table width=600><tr><td>
<h1>README</h1>
<h2>REPRESENTING THE CUBE STATE</h2>
<p>Each cubie is represented by one of the facelets. The relevant facelets are numbered as
follows:
<br><center><img src="nums.png"></center>
<p>There are 24 positions for edge facelets and 24 positions for corner facelets. The positions
are labelled below:
<br><center><img src="pos.png"></center>
<p>The positions of the 12 edges are stored in the array <i>edges</i> and the positions of the 8 corners are stored in the array <i>corners</i>.
<p>The position of the U facelet of the UF edge cubie is stored in edges[0], the
position of the U facelet of the UR cubie in edges[1], and so forth.
Similarly, the position of the U facelet of the UFR corner cubie is in corners[0], the 
position of the U facelet of the URB cubie in corners[1], and so forth.
<p>A solved cube has an edges array of {0, 1, 2, 3, 8, 9, 10, 11, 20, 21, 22, 23} and corners
array of {0, 1, 2, 3, 20, 21, 22, 23}. After the move R+, the resulting arrays are {0, 13, 2, 3, 1, 17, 10, 11, 20, 8, 22, 23} and
{9, 17, 2, 3, 4, 12, 22, 23}, respectively.
<h2>SOLVING METHOD</h2>
<p>This program solves the cube using a method that humans never use. However, it is well
suited for computers because it is highly repetitive. (It is easy to code too!) One cubie
is solved at a time, restricting the unsolved ones to fewer and fewer positions, until the
entire cube is solved.
The method goes like this:
<pre>
  for i = 1 to 4 {
    solve the DF edge
    rotate cube
  }
  for i = 1 to 4 {
    solve the DRF corner
    rotate cube
  }
  for i = 1 to 4 {
    solve the FR edge
    rotate cube
  }
  for i = 1 to 4
    solve the URF corner
    rotate cube
  }
  for i = 1 to 4
    solve the UF edge
    rotate cube
  }
</pre>
where <i>rotate</i> is a cube rotation in the direction of a U turn. The cube usually takes
around 105 moves to solve using this method.

<h2>CODING ALGORITHMS</h2>
<p>To reduce the program size, the algorithms are encoded. In prior versions,
each move was given a number and an array of numbers represented an algorithm.
In this version, an algorithm is converted into a long integer.
<p>First, the moves are assigned the following values:
<pre>
      X+  X2  X-
  ----------------
   F   1   2   3
   R   4   5   6
   B   7   8   9
   L  10  11  12
   U  13  14  15
   D  16  17  18
</pre>
For the algorithm R+ U+ R-, I turn it into an integer as follows:
<p>4*19<sup>0</sup> + 13*19<sup>1</sup> + 6*19<sup>2</sup> + 0*19<sup>3</sup> + 0*19<sup>4</sup> + 0*19<sup>5</sup> + 0*19<sup>6</sup> = 2417
<p>A zero indicates the end of the algorithm. Longer algorithms are broken into chunks of 7 
moves.
<h3>Charles Tsai
<br>Canton, MA
<br>USA
<br>c_w_tsai@yahoo.com</h3>

</td></tr></table>
</body>
</html>